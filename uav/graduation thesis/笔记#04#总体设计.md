## 地面站实际效果

　　整个地面站软件包括后端部分以及前端部分。后端部分负责与无人机进行数据交互，而前端部分则专门用于可视化来自无人机的数据。我们首先需要启动地面站后端，然后通过浏览器来打开地面站的前端。飞控是用于调试地面站的数据源。在开始一切操作之前，我们首先需要把飞控通过USB数据线和即将运行地面站软件的个人电脑连接起来。

（附带一张图）

　　连接好之后，假设读者已在本地打开并且成功编译了地面站代码。这个时候，为了避免占用内存，可以先将Visual Studio 2017关闭。然后在地面站项目的根目录中的SimpleGCS4MAVLink\bin\Debug文件夹下找到SimpleGCS4MAVLink.exe，双击这个可执行程序。如果一切正常，将弹出一个Windows窗体，以及命令行形式的后台信息窗，并提示我们WebSocket服务已开启。这时，我们在弹出的窗口中选择连接飞控硬件的相应端口，以及波特率（通常是115200，具体飞控可能略有不同）。然后点击“连接”。将在命令行看到“设备已连接”的提示。反之，如果在连接状态下再一次点击“连接”，则断开。

![img](https://img2020.cnblogs.com/i-beta/1042431/202003/1042431-20200316105718193-686234900.png)

　　此时地面站后端已经开始和飞控进行数据交换了。我们现在需要一个视图将地面站所接收的数据可视化。在本地面站实现中，我们通过浏览器来访问地面站的前端视图。在联网情况下，重新转到项目根目录中的www文件夹下，找到index.html，直接双击打开该网页存在一个跨域的问题，将导致视图中的部分模块无法正常显示。所以就不得不在本地启动一个临时的web服务程序，在这里，我采用Python来完成这一项工作，在已安装Python的状况下，只需要python -m http.server 8000这一行指令（8000是端口号，可以更换为不与本地程序所占用端口冲突的其余任何端口号）。当然，读者也可尝试采取其它办法来启动一个web服务程序，其效果是一样的。

![img](https://img2020.cnblogs.com/i-beta/1042431/202003/1042431-20200316142948800-1949929479.png)

　　开启临时的web服务程序之后，就可以在浏览器中，通过相应地址访问地面站前端视图了。在本文中该地址为http://localhost:8000/。

![img](https://img2020.cnblogs.com/i-beta/1042431/202003/1042431-20200316144237221-820585811.png)

　　如上图所示，地面站前端视图的左上角是一个姿态指引仪。它的作用是动态地反映无人机的飞行姿态，具体而言，它主要基于无人机的这些实时数据：俯仰（pitch）、横滚（roll），偏航（yaw）。在整个网页的“底部”是一幅动态的地图，蓝色的标记点用于标记无人机的实时位置。而右上角则是一个数据面板，用于实时显示无人机的高度、地速等。最后，在视图左下角，是一个进一步反映无人机飞行姿态的3D模型，相较于姿态指引仪，更加直观，有利于我们更精准地监视、操控无人机。

## 基本原理

　　关于软件运行的基本原理，实际上已经在上一章“MAVLink基本通信流程”中大致说明了。首先，无人机源源不断地向地面站发送心跳包，然后地面站向无人机发送REQUEST_DATA_STREAM消息包，之后无人机按一定频率返回实时数据。接下来，说明一些编程方面的关键点。地面站的后端，根本上是依赖于C#中的SerialPort对象与飞控建立实际的数据连接。地面站后端只做了这么几件事情：接收数据，其依赖于SerialPort对象；发送数据，仍然依赖于SerialPort对象；将数据转发至地面站前端，依赖于来自外部库的WebSocketServer对象。其余所做的一切工作，基本上是对这两个对象进行进一步的封装，以便代码易于理解和修改。

　　另外一个关键的地方是，地面站后端不是一定需要把数据交付给WebSocketServer对象。地面站前端和后端其实是“松耦合”的。也就说，并非一定要用浏览器来将数据可视化，也可以完全采用C#来实现地面站的前端视图，并且不需要更改很多代码。至于更多关于程序构造方面的细节，将在下两章进一步阐述。